# Oliver-RISC: The Ultimate RISC Processor

The CPU has 8MB of SDRAM.
On bootup, the FPGA loads a binary from the ROM to the SDRAM (at address 32'd0). The FPGA detects the magic byte (the CODE instruction), which it uses to know where the .data section ends and the .code section begins. The FPGA then starts executing instructions from the start of the .code section. The .data and .code sections are addressed separately.

Registers (32 bits each, addressed using a 32-bit code):
IP - 32'd0 - Instruction pointer. SDRAM address of the instruction to execute.
A - 32'b1  - Used for the result of ADD, SUB, and CMP instructions.
B - 32'b2  - Generic register.
C - 32'b3  - Generic register.
D - 32'b4  - Generic register.
E - 32'b5  - Generic register.
F - 32'b6  - Generic register.
G - 32'b7  - Generic register.
IE - 32'b8 - Interrupt-enable register. Allows interrupts only when IE == 'b1.
IR - 32'b9 - Interrupt-running register. Is set to 1 while an interrupt in is progress.

Shadow registers:

Instructions:
* NOP                                             - No operation. Useful for delays.

* LOAD <memory_address>,<register>                - Load the 32 bits at <memory_address> in SDRAM into the register identified by <register>
* STORE <register>,<memory_address>               - Save the 32 bits in <register> to <memory_address> in SDRAM.
* RLOAD <register1>,<register2>                   - Load the 32 bits at the memory address stored in <register1> into <register2>.
* RSTORE <register1>,<register2>                  - Save the 32 bits in <register1> to the memory address stored in <register2>.
* CLOAD <constant>,<register>                     - Load a 32-bit constant operand into a register.

* ADD <register1>,<register2>                     - Add <register1> to <register2> and store the result in register A.
* SUB <register1>,<register2>                     - Subtract <register2> from <register1> and store the result in register A.

* OUT <register1>,<register2>                     - Write the contents of <register2> to the port number stored in <register1>.
* IN <register1>,<register2>                      - Read from the port specified in <register1> into the register specified in <register2>.

* MOV <register1>,<register2>                     - Copy register1 to register2.

* CMP <register1>,<register2>                     - If register1 < register2, set reg A to 0. If =, set reg A to 1. If >, set reg A to 2.
* JMPL <memory_address>,                          - If reg A == 0, jump the instruction pointer register to <memory_address>.
* JMPE <memory_address>,                          - If reg A == 1, jump the instruction pointer register to <memory_address>.
* JMPG <memory_address>,                          - If reg A == 2, jump the instruction pointer register to <memory_address>.

* RST                                             - Clear all registers to 0 (including the instruction pointer).
* HALT                                            - Stop the CPU.

* ISR <register1>,<register2>                   - Sets up an interrupt service routine. <register1> is the register containing the interrupt number (8 interrupts are available). <register2> is a register containing the address of the first instruction in the ISR.
* INT <register>,                                 - Triggers an interrupt from software. <register> is the register containing the interrupt number (8 interrupts exist).
* ENDINT                                          - Ends an interrupt routine. MUST be placed as the last instruction in an interrupt routine. Restores all registers (including the instruction pointer) to their states before the interrupt was executed.

* CODE                                            - Switch from the .data section of the program to the .code section.

Example program to print out numbers 1-5:
.data:
	start = 1
	step  = 1
	end   = 5
.code:
	LOAD start,B
	LOAD step,C
	LOAD end,D
	begin:
		OUT B,
		ADD B,C
		MOV A,B
		CMP B,D
		JMPL, begin
		JMPE, begin
		JMPG, finish
	finish:
		HALT

Interrupt system:
When an interrupt event is fired AND interrupt-enable register is 1, it gets pushed to a FIFO of interrupts.
When the CPU decides it has time to execute the interrupt, then it pops it from the FIFO. It then looks up the interrupt number in the IVT (interrupt vector table). It uses the IVT to find the memory address of the ISR (interrupt service routine).
It copies all registers (IP and A-G) to the set of shadow registers. It then sets the IP register to the memory address of the ISR and executes ISR code. The ISR code sets the interrupt-running register to 1 to indicate that an interrupt is being run. While this register is 1, new interrupts will be added to the FIFO but not executed.
At the end of the ISR, it calls the ENDINT instruction, which copies all of the shadow registers over to the normal registers. This has the effect of setting the IP and interrupt-running registers back to what they were before.
The program then a) does the next interrupt in the FIFO or b) keeps executing normal code if there are no more interrupts in the FIFO.

Future planned features:
Use a stack to push/pop the call stack.
GPIO control instructions.
A proper ALU.
Pipelining of RAM operations.
