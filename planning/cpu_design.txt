# Oliver-RISC: The Ultimate RISC Processor

The CPU has 8MB of SDRAM.
The SDRAM is split into the .data and the .code sections.
On bootup, the FPGA reads out a binary from the SD card or RAM and places it at 32'd0 in the code RAM.
The FPGA then reads the first instruction from 32'd0 and executes it. Then, it executes the next instruction, etc.

Registers (32 bits each, addressed using a 32-bit code):
IP - 32'd0 - Instruction pointer. SDRAM address of the instruction to execute.
A - 32'b1  - Used for the result of ADD, SUB, and CMP instructions.
B - 32'b2  - Generic register.
C - 32'b3  - Generic register.
D - 32'b4  - Generic register.
E - 32'b5  - Generic register.
F - 32'b6  - Generic register.
G - 32'b7  - Generic register.
IE - 32'b8 - Interrupt-enable register. Allows interrupts only when IE == 'b1.
IR - 32'b9 - Interrupt-running register. Is set to 1 while an interrupt in is progress.

Shadow registers:

Instructions:
* NOP                                             - No operation. Takes 1 clock cycle.
* LOAD <memory_address>,<register>                - Load the 32 bits at <memory_address> in SDRAM into the register identified by <register>
* STORE <register>,<memory_address>               - Save the 32 bits in <register> to <memory_address> in SDRAM.
* ADD <register1>,<register2>                     - Add <register1> to <register2> and store the result in register A.
* SUB <register1>,<register2>                     - Subtract <register2> from <register1> and store the result in register A.
* OUT <register>,                                 - Write the contents of <register> to serial.
* IN <register>,                                  - Read 32 bits from serial and place them in <register>.
* MOV <register1>,<register2>                     - Copy register1 to register2.
* CMP <register1>,<register2>                     - If register1 < register2, set reg A to 0. If =, set reg A to 1. If >, set reg A to 2.
* JMPL <memory_address>,                          - If reg A == 0, jump the instruction pointer register to <memory_address>.
* JMPE <memory_address>,                          - If reg A == 1, jump the instruction pointer register to <memory_address>.
* JMPG <memory_address>,                          - If reg A == 2, jump the instruction pointer register to <memory_address>.
* RST                                             - Clear all registers to 0 (including the instruction pointer).
* HALT                                            - Stop the CPU.
* ISR <register>,<code_address>                   - Sets up an interrupt service routine. <register> is the register containing the interrupt number (8 interrupts are available). <code_address> is the address of the first instruction in the ISR routine.
* INT <register>,                                 - Triggers an interrupt from software. <register> is the register containing the interrupt number (8 interrupts exist).
* ENDINT                                          - Ends an interrupt routine. MUST be placed as the last instruction in an interrupt routine. Restores all registers (including the instruction pointer) to their states before the interrupt was executed.
* CODE                                            - Switch from the .data section of the program to the .code section.

Example program to print out numbers 1-5:
.data:
	start = 1
	step  = 1
	end   = 5
.code:
	LOAD start,B
	LOAD step,C
	LOAD end,D
	begin:
		OUT B,
		ADD B,C
		MOV A,B
		CMP B,D
		JMPL, begin
		JMPE, begin
		JMPG, finish
	finish:
		HALT

Interrupt system:
When an interrupt event is fired AND interrupt-enable register is 1, it gets pushed to a FIFO of interrupts.
When the CPU decides it has time to execute the interrupt, then it pops it from the FIFO. It then looks up the interrupt number in the IVT (interrupt vector table). It uses the IVT to find the memory address of the ISR (interrupt service routine).
It copies all registers (IP and A-G) to the set of shadow registers. It then sets the IP register to the memory address of the ISR and executes ISR code. The ISR code sets the interrupt-running register to 1 to indicate that an interrupt is being run. While this register is 1, new interrupts will be added to the FIFO but not executed.
At the end of the ISR, it calls the RET instruction, which copies all of the shadow registers over to the normal registers. This has the effect of setting the IP and interrupt-running registers back to what they were before.
The program then a) does the next interrupt in the FIFO or b) keeps executing normal code if there are no more interrupts in the FIFO.

Future planned features:
Interrupt handling for timing, GPIO events, and keyboard input. Use a set of shadow registers to save registers. Use interrupt vector table. Use interrupt-enable register.
Use a stack to push/pop the call stack.
GPIO control instructions.
A proper ALU.
Pipelining of RAM operations.
