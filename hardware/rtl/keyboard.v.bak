module keyboard(
    input CLOCK_50,
    input PS2_CLK,
    input PS2_DAT,
    output reg [7:0] scancode = 0,
    output wire ready,
    output reg done, // DEBUG
    output reg other_done // DEBUG
);

reg [10:0] shift_register = 0;
//assign scancode = shift_register[8:0]; // The first bit of PS/2 is a start bit, the second-to-last is a parity bit, and the last is a stop bit.

reg[$clog2(11) - 1:0] bits_counter = 0; // PS/2 has 11 bits per byte transmitted.
//reg done;
//reg other_done;

initial begin
    shift_register <= 'b0;
    bits_counter <= 'b0;
    done <= 'b0;
    other_done <= 'b0;
end

assign ready = done & other_done;

reg [7:0] ps2_clk_filter = 0;
wire [7:0] ps2_filter_next;
assign ps2_filter_next = {PS2_CLK, ps2_clk_filter[7:1]};
reg filter_value = 0;
wire filter_value_next;
always @(posedge CLOCK_50)
begin
    ps2_clk_filter <= ps2_filter_next;
    filter_value <= filter_value_next;
end

assign filter_value_next = (ps2_clk_filter == 8'b11111111) ? 1'b1 : (ps2_clk_filter == 8'b00000000) ? 1'b0 : filter_value;

wire ps2_clk_falling;
assign ps2_clk_falling = filter_value & ~filter_value_next;

always @(posedge CLOCK_50)
begin
    if (ps2_clk_falling)
    begin
        shift_register <= shift_register >> 1;
        shift_register[9] <= PS2_DAT;
        bits_counter <= bits_counter + 'b1;
        if (bits_counter == 'd10)
        begin
            bits_counter <= 'b0;
            done <= 'b1;
        end
        else
            done <= 'b0;
    end
end

assign bits_counter_finished = (bits_counter == 'd10);

always @(posedge bits_counter_finished or posedge PS2_CLK or posedge CLOCK_50)
begin
    if (bits_counter_finished)
        other_done <= 'b1;
    else
    begin
        if (CLOCK_50 == 'b1)
            other_done <= 'b0;
    end
end

always @(posedge CLOCK_50)
begin
    if (ready)
        scancode <= shift_register[8:0];
end

endmodule
